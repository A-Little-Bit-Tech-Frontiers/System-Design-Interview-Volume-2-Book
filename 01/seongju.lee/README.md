## 데이터베이스의 규모 확장성

두 가지 테이블인 사업장 테이블과 지리 정보 색인 테이블의 규모 확장성을 살펴보자.

- **사업장 테이블**
    
    사업장 테이블 데이터는 한 서버에 담을 수 없을 수 있다. 따라서 **샤딩**을 적용하기 좋은 후보이다. 이 테이블을 샤딩하는 가장 간단한 방법은 사업장 ID를 기준으로 하는 것이다. 모든 샤드에 부하를 고르게 분산할 수 있을 뿐 아니라 운영적 측면에서 보자면 관리하기도 쉽다.

    <br>
    
- **지리 정보 색인 테이블**
    
    위치 검색 알고리즘을 통해 나온 결과를 저장하는데는 두 가지 방안이 있다. 여기선 알고리즘을 통해 나온 결과를 해시값이라고 하자.
    
    **방안1**: 각각의 해시값에 연결되는 모든 사업장 ID를 JSON 배열로 만들어 같은 컬럼에 저장하는 방식
    
    | geospatial_index |
    | --- |
    | geohash
    list_of_business_ids |
    
    **방안2**: 같은 해시값에 속한 사업장 ID를 각각의 별도 열로 저장하는 방안
    
    | geospatial_index |
    | --- |
    | geohash
    business_id |
    
    | geohash | business_id |
    | --- | --- |
    | 32feac | 343 |
    | 32feac | 347 |
    | f31abc | 110 |
    
    방안 1의 경우 사업장 정보를 갱신하려면 일단 JSON 배열을 읽은 다음 갱신할 사업장 ID를 찾아내야 한다. 새 사업장을 추가하더라도 모든 데이터를 전부 살펴야 한다. 또한 **병렬적으로 실행되는 갱신 연산 결과로 데이터가 소실되는 경우를 막기 위해 락을 사용해야 한다.**
    
    하지만, 방안 2는 해시값과 사업장 ID를 합친 복합키로 사용하면 매우 간단하며, 락을 사용할 필요도 없다.

  <br>

- **지리 정보 색인의 규모 확장**
  
  지리 정보 색인의 규모를 확장할 때 **테이블에 보관되는 데이터의 실제 크기를 고려하지 않고 성급하게 샤딩 방법을 결정하는 실수**를 흔히 저지르곤 한다. 여기서 살펴보는 지리 정보 색인 테이블 구축에 필요한 전체 데이터 양은 많지 않다. 따라서 색인 전부를 최신 데이터베이스 서버 한 대에 충분히 수용할 수 있다. 하지만 읽기 연산의 빈도가 높다면 서버 한 대의 CPU와 네트워크 대역폭으로는 요청 전부를 감당하지 못할 수 있다. 그런 상황에서는 여러 데이터베이스 서버로 부하를 분산해야 한다.
  
  관계형 데이터베이스 서버의 경우 부하 분산에는 두 가지 전략이 힌히 사용된다. 하나는 읽기 연산을 지원하는 사본 데이터베이스 서버를 늘리는 것, 다른 하나는 샤딩이다.
  
  이러한 지리 정보 색인의 해시를 저장하는 테이블은 샤딩이 까다롭다. 샤딩 로직을 애플리케이션 계층에 구현해야 하기 때문이다.  샤딩이 유일한 선택지일 때도 있지만 해당 설계안의 경우에는 데이터 전부를 서버 한대에 담을 수 있으므로 그렇게까지 샤딩의 필요성은 없다. 따라서 읽기전용 레플리카를 두는 것이 낫다는 판단을 할 수 있다.

    <br>
    
- **캐시**
    
    캐시 계층은 도입 전에 정말 필요한가?에 대해서 꼭 생각해봐야 한다.
    
    - 처리 부하가 읽기 중심이고 데이터베이스 크기는 상대적으로 작아서 모든 데이터는 한 대 데이터베이스 서버에 수용 가능하다. 이 경우 질의문 처리 성능은 I/O에 좌우되지 않으므로 메모리 캐시를 사용할 때와 비슷하다.
    - 읽기 성능이 병목이라면 레플리카를 두어 읽기 대역폭을 늘릴 수 있다.

<br>

- **캐시 키**
    
    가장 직관적인 캐시 키는 사용자 위치의 위도 경도 정보다. 하지만 여기에는 몇 가지 문제가 존재
    
    - 사용자의 휴대폰에서 반환되는 위치 정보는 추정치일 뿐 아주 정확하지 않다. 설사 전혀 움직이지 않는다고 해도, 그 정보는 측정할 때마다 조금씩 달라진다.
    - 사용자가 이동하면 해당 위도 및 경도 정보도 미세하게 변경된다. 대부분의 애플리케이션에 이 변화는 아무런 의미가 없다.
    
    따라서, 여기에선 해시값을 키로 두어 해결한다.




## 설계도
<img width="521" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/940028b1-4e9e-49dc-87c5-47559a6e47d6">  

1. 주변 반경 500미터 내 모든 식당을 찾는 경우를 생각해보자. 우선 클라이언트 앱은 사용자의 위치와 검색 반경을 로드밸런서로 전송한다.
2. 로드밸런서는 해당 요청을 LBS로 보낸다.
3. 주어진 사용자 위치와 반경 정보에 의거하여, LBS는 검색 요건을 만족할 해시 길이를 계산한다.
4. LBS는 인접한 해시를 계산한 다음 목록에 추가한다.
5. 해시 목록에 있는 각각에 대해 LBS는 (지오)해시 레디스 서버를 호출하여 해당 해시에 대응하는 모든 사업장 ID를 추출한다. 해시별로 사업장 ID목록을 가져오는 연산을 병렬적으로 수행하면 검색 결과를 내는 지연시간을 줄일 수 있다.
6. 반환된 사업장 ID들을 가지고 ‘사업장 정보’ 레디스 서버를 조회하여 각 사업장의 상세 정보를 취득한다. 해당 상세 정보에 의거하여 사업장과 사용자 간 거리를 확실하게 계산하고, 우선순위를 매긴 다음 클라이언트에게 반환한다.
