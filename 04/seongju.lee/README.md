# 분산 메시지 큐

## 1. 메시지 모델

  
### 일대일 모델

전통적인 메시지 큐에서 발견되는 모델로, 흔히들 Producer/Consumer 방식이라고 한다. 메시지를 가져가는 소비자는 하나 뿐이다.

소비자가 메시지를 가져갔다는 사실을 큐에 ack를 보내면 메시지는 큐에서 삭제된다.

<img width="940" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/4df44a22-3359-46b0-af81-2b26be57e018">

  
### 발행-구독 모델

topic이라는 개념을 도입한 모델로, Publish/Subscriber 방식이라고 부른다. 각 토픽은 메시지를 주제별로 정리하는 데 사용되며, 메시지를 보내고 받을 때는 토픽에 보내고 받게 된다.

해당 토픽을 구독하고 있는 모든 소비자가 메시지를 가져간다.

<img width="773" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/5dc3f1d9-3a5b-4178-b90d-43642b683076">


  
## 2. 메시지 데이터 저장소

메시지를 어떻게 지속적으로 저장할 수 있을까?

메시지 큐의 트래픽 패턴

- 읽기와 쓰기가 빈번하게 일어난다.
- 갱신/삭제 연산은 발생하지 않는다.(메시지 큐 x, 데이터 스트리밍 플랫폼)
- 순차적인 읽기/쓰기가 대부분이다.

  
### 선택지 1: 데이터베이스

RDB: 토픽별 테이블 생성
NoSQL: 토픽별 컬렉션 생성

데이터베이스라면 데이터 저장 요구사항은 맞출 수 있지만, 읽기 연산과 쓰기 연산이 동시에 대규모로 빈번하게 발생하는 상황을 잘 처리하는 데이터베이스는 설계하기 어렵기에 적합하지 않다.

  
### 선택지 2: 쓰기 우선 로그(Write-Ahead Log, WAL)

append-only 방식의 파일인 WAL로 메시지를 보관할 수 있다. MySQL의 redo log나 아파치 주키퍼가 해당 기술을 활용한다.

지속성을 보장해야 한다면 좋은 방식인데, WAL에 대한 접근 패턴은 읽기/쓰기 전부 순차적이다. 덕분에 좋은 성능을 보인다.

<img width="825" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/26e552bf-c30c-4633-8d83-0a492b9a8af3">

새로운 메시지는 파티션 꼬리 부분에 추가되며, 오프셋은 그 결과로 점진적으로 증가한다. 가장 쉬운 방법은 로그 파일 줄 번호를 오프셋으로 사용하는 것이다. 하지만 파일의 크기도 무한정 커질 수는 없으니, **세그먼트 단위**로 나누는 것이 바람직하다.
해당 세그먼트의 크기가 일정 한계에 도달하면 새 활성 세그먼트 파일이 만들어져 새로운 메시지를 수용하고, 종전까지 활성 상태였던 세그먼트 파일은 다른 나머지 세그먼트 파일과 마찬가지로 비활성 상태로 바뀐다. 비활성 세그먼트는 읽기 요청만 처리한다.
낡은 비활성 세그먼트 파일은 보관 기한이 만료되거나 용량 한계에 도달하면 삭제해 버릴 수 있다.

<img width="863" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/b0ffc629-248c-4734-80a9-433522ee16b6">

  
## 3. 상태 저장소

메시지 큐 브로커의 상태 저장소에는 다음과 같은 정보가 저장된다.

- 소비자에 대한 파티션의 배치 관계
- 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋. 아래 그림처럼 그룹-1의 마지막 오프셋은 6이고, 그룹-2의 마지막 오프셋은 13이다.

<img width="906" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/7f0c8bbe-67be-4f26-ae17-081eaeb57316">

그룹 1의 한 소비자가 파티션의 메시지를 순서대로 읽은 후 마지막으로 읽어간 메시지의 오프셋을 6으로 갱신하였다. 즉, 6을 포함하여 그 앞 모든 메시지는 읽었갔다는 뜻이다. 해당 소비자에 장애가 생기면 같은 그룹의 새로운 소비자가 이어받아 해당 위치 다음부터 메시지를 읽어갈 것이다.

소비자 상태 정보 데이터가 이용되는 패턴은 다음과 같다.

- 읽기와 쓰기가 빈번하게 발생하지만 양은 많지 않다.
- 데이터 갱신은 빈번하지만 삭제되는 일은 거의 없다.
- 읽기와 쓰기 연산은 무작위적 패턴을 보인다.
- 데이터의 일관성이 중요하다.

## 4. 컨슈머 리밸런싱



  
## 5. 메타데이터 저장소

메타데이터 저장소에는 토픽 설정이나 속성 정보를 보관한다. 파티션 수, 메시지 보관 기간, 사본 배치 정보 등이 이에 해당한다. 자주 변경되지 않으며 양도 적다. 하지만 높은 일관성을 요구하는데, 이는 주키퍼가 적절하다.

  
### 주키퍼

<img width="938" alt="image" src="https://github.com/A-Little-Bit-Tech-Frontiers/System-Design-Interview-Volume-2-Book/assets/67941526/1ce88a8f-dd1a-4726-93b6-73ff64dd8809">  

주키퍼는 계층적 키-값 저장소 기능을 제공하는, 분산 시스템에 필수적인 서비스이다.
