# 호텔 예약 시스템

## 1. 개략적 설계

## 1.1 API 설계

- 호텔 관련 API (호텔 상세 정보, 호텔 추가/갱신/삭제 → 호텔 직원만 사용 가능)
- 객실 관련 API (객실 상세 정보, 객실 추가/갱신/삭제 → 호텔 직원만 사용 가능)
- 예약 관련 API (현재 사용자의 예약 이력, 특정 예약의 상세 정보, 신규 예약, 예약 취소)

위 API 정도로 구상해볼 수 있다. 여기서 신규 예약 접수는 아주 중요한 기능이다. 새 예약(POST /v1/reservations)을 만들 때 API에 전달하는 인자의 형태는 아래와 같다.

```json
{
	"startDate": "2024-07-17",
	"endDate": "2024-07-20",
	"hotelId": "245",
	"roomId": "U123456789",
	"reservationId": "12345"
}
```

`reservationId`는 이중 예약을 방지하고 동일한 예약은 단 한번만 이루어지도록 보증하는 멱등 키이다. 여기서 이중 예약은 같은 날 같은 객실에 예약이 중복으로 이루어진 것을 말한다.


## 1.2 설계안

<img width="564" alt="image" src="https://github.com/user-attachments/assets/eff9efc4-9f18-4a32-bfc3-0fd7c109332b">

- 사용자: 휴대폰이나 컴퓨터로 객실을 예약하는 당사자
- 관리자(호텔 직원): 고객 환불, 예약 취소, 객실 정보 갱신 등의 관리 작업을 수행할 권한이 있는 호텔 직원이다.
- CDN(콘텐츠 전송 네트워크): 자바스크립트 코드 번들, 이미지, 동영상, HTML 등 모든 정적 콘첸트를 캐시하여 웹사이트 로드 성능을 개선하는 데 이용된다.
- 공개 API 게이트웨이: 처리율 제한(rate limiting), 인증 등의 기능을 지원하는 완전 관리형 서비스(fully managed service)다. 엔드포인트 기반으로 특정 서비스에 요청을 전달할 수 있도록 구성된다. 
예를 들어 호텔 홈페이지 요청은 호텔 서비스로, 호텔 객실 예약 요청은 예약 서비스로 전달하는 역할을 담당한다.
- 내부 API: 승인된 호텔 직원만 사용 가능한 API로, 내부 소프트웨어나 웹사이트를 통해서 사용 가능하다. VPN(Virtual Private Network) 등의 기술을 사용해 외부 공격으로부터 보호된다.
- 호텔 서비스: 호텔과 객실에 대한 상세 정보를 제공한다. 호텔과 객실 데이터는 일반적으로 정적이라서 쉽게 캐시해 둘 수 있다.
- 요금 서비스: 미래의 어떤 날에 어떤 요금을 받아야 하는지 데이터를 제공하는 서비스다. 재미있는 것은 객실의 요금은 해당 날짜에 호텔에 얼마나 많은 손님이 몰리느냐에 따라 달라진다는 것이다.
- 예약 서비스: 예약 요청을 받고 객실을 예약하는 과정을 처리한다. **객실이 예약되거나 취소될 때 잔여 객실 정보를 갱신하는 역할도 담당한다.**
- 결제 서비스: 고객의 결제를 맡아 처리하고, **절차가 성공적으로 마무리되면 예약 상태를 결제 완료로 갱신하며 실패한 경우에는 승인 실패로 업데이트**한다.
- 호텔 관리 서비스: 승인된 호텔 직원만 사용 가능한 서비스다. 임박한 예약 기록 확인, 고객 객실 예약, 예약 취소 등의 기능을 제공한다.



## 2. 상세 설계

### 2.1 데이터 모델

<img width="499" alt="image" src="https://github.com/user-attachments/assets/75234dcb-5bf8-427c-a27a-926e62e14dbe">

- room: 객실에 관계된 정보를 담는다.
- room_type_rate: 특정 객실 유형의 특정 일자 요금 정보를 담는다.
- reservation: 투숙객 예약 정보를 담는다.
- room_type_inventory: 호텔의 모든 객실 유형을 담는 테이블이다. 예약 시스템에 아주 중요하니, 각 열의 의미를 자세히 짚어보자.
    - hotel_id: 호텔 식별자
    - room_type_id: 객실 유형 식별자
    - date: 일자
    - total_inventory: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값이다. 일부 객실은 유지보수를 위해 예약 가능 목록에서 빼 둘 수 있어야 한다. (room_type 뿐만 아니라 타입에 따른 재고를 관리해야 하므로 별도의 테이블로 분리 👍)
    - total_reserved: 지정된 hotel_id, room_type_id, date에 예약된 모든 객실의 수

`room_type_inventory`와 같이 날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다. (특정 유형 객실의 예약 여부를 확인할 때 사용하는 테이블인 것처럼 특정기능을 최적의 성능으로 제공하기 위해 과감하게 테이블을 분리)
이 테이블의 기본키는 (hotel_id, room_type_id, date)의 복합키다. 이 테이블은 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.


### 2.2 시스템 규모 확장

**2.2.1 데이터베이스 샤딩**
데이터베이스의 규모를 한 가지 방법은 샤딩을 적용하는 것이다. 데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 하는 것이 기본적인 아이디어다. 샤딩할 때는 데이터를 어떻게 분배할지 먼저 정해야 한다.  
이 시스템의 대부분 질의는 hotel_id를 필터링 조건으로 사용한다. 따라서 자연스럽게 hotel_id를 샤딩 조건으로 쓰면 좋을 것 같다.


**2.2.2 캐시**

호텔 잔여 객실 데이터에는 재미있는 특성이 있다. 오직 현재 그리고 미래의 데이터만이 중요하다는 것이다. 고객이 과거의 어떤 객실을 예약하려 하지는 않을 것이기 때문이다.  
따라서 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL(Time-To-Live)을 설정할 수 있다면 바람직하다. 
이력 데이터에는 다른 데이터베이스를 통해 질의하도록 하면 된다. **레디스는 이런 상황에 적합한데 TTL과 LRU 캐시 교체 정책을 사용하여 메모리를 최적으로 활용할 수 있기 때문**이다.  
데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다. 
이렇게 하면 요청 가운데 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당한다.

- TTL을 통해 낡은 데이터를 소멸되도록 처리하는 것이 인상적
- 이를 최적으로 활용하기 위해 Redis를 선택한것도 기억해두면 좋을 듯하다.
