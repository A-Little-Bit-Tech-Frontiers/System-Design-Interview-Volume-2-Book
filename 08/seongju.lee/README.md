# 분산 이메일 서비스

## 1. 개략적 설계안


### 1.1 전통적 메일 서버 아키텍처

<img width="537" alt="image" src="https://github.com/user-attachments/assets/4d447e70-80e2-4bd9-85ac-fe19b19c4525">

1. 앨리스는 아웃룩 클라이언트에 로그인하여 이메일 '보내기'버튼을 클릭한다. 이메일은 아웃룩 **메일 서버로 전송**된다. 아웃룩 클라이언트와 메일 서버 사이의 통신 프로토콜은 SMTP이다.
2. 아웃룩 메일 서버는 DNS 질의를 통해 수신사 SMTP 서버 주소를 찾는다. 이 경우에는 지메일의 SMTP 서버 주소다. 주소를 알고 나면 해당 메일 서버로 이메일을 보낸다. 메일 서버 간 통신 프로토콜도 SMTP다.
3. 지메일 서버는 이메일을 저장하고 수신자인 밥이 읽어갈 수 있도록 한다.
4. 밥이 지메일에 로그인하면 지메일 클라이언트는 IMAP/POP 서버를 통해 새 이메일을 가져온다.

### 1.2 분산 메일 서버 아키텍처

<img width="573" alt="image" src="https://github.com/user-attachments/assets/c141180e-14ac-4bee-a608-e978987fd219">

- 웹메일: 사용자는 웹브라우저를 사용해 메일을 받고 보낸다.
- 웹서버: 웹서버는 사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당한다. 본 설계안의 경우 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등의 모든 잉메일 API 요청은 전부 웹서버를 통한다.
- 실시간 서버: 실시간 서버는 새로운 이메일 내역을 클라이언트에 실시간으로 전달하는 역할을 담당한다. **실시간 서버는 지속성 연결을 맺고 유지해야 하므로 stateful 서버**다. 실시간 통신 지원 방안으로는 롤 폴링이나 웹소켓 등이 있다.
그 중에는 **웹소켓이 좀 더 우아하지만 브라우저 호환성 문제가 있을 수 있다.** 한 가지 해결책은 **기본적으로는 웹소켓을 쓰되 여의치 않으면 롤 폴링을 백업으로 이용**하는 것이다.

- 메타데이터 데이터베이스: 이메일 제목, 본문, 발신인, 수신인 목록 등의 메타데이터를 저장하는 데이터베이스다.
- 첨부파일 저장소: 아마존 S3 같은 객체 저장소를 사용한다. S3는 이미지나 동영상 등의 대용량 파일을 저장하는 데 적합한, 확장이 용이한 저장소 인프라다.

- 분산 캐시: 최근에 수신된 이메일은 자주 읽을 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해 두도록 하면 메일을 표시하는 시간을 많이 줄일 수 있다. 리스트 같은 다양한 기능을 제공하는 데다 규모 확장도 용이하므로 레디스를 활용한다.
- 검색 저장소: 분산 문서 저장소다. 고속 텍스트 검색을 지원하는 역 인덱스를 자료구조로 사용한다.


## 2. 상세 설계

### 2.1 메타데이터 저장소

**메타데이터 특성**

- 이메일 본문의 크기는 작은 것부터 큰 것까지 다양하지만 사용 빈도는 낮다.
- 이메일 가져오기, 읽음 표시, 검색 등의 이메일 관련 작업은 사용자별로 격리 수행되어야 한다.
- 데이터 신선도는 데이터 사용 패턴에 영향을 미친다. 사용자는 보통 최근 메일만 읽는다.
- 데이터의 높은 안정성이 보장되어야 한다. 데이터 손실은 용납되지 않는다.

**올바른 데이터베이스 선정**

지메일이나 아웃룩 정도의 규모가 되면 보통 초당 입/출력 연산 빈도(Input/Output Operations Per Second, IOPS)를 낮추기 위해 맞춤 제작한 데이터베이스를 사용하는데 시스템에 큰 부담이 되기 때문이다.
가능한 모든 선택지는 미리 살펴보자.

- 관계형 데이터베이스: RDB는 이메일을 효율적으로 검색할 수 있기 때문에 고를 수 있다. 이메일 헤더와 본문에 대한 인덱스를 두면 간단한 검색 질의는 빠르게 처리할 수 있다. 하지만 RDB는 데이터 크기가 작을 때 적합하다.  
보통 이메일은 수 KB보다 크고 HTML이 포함되면 쉽게 100KB가 넘어간다. BLOB 자료형을 쓰면 큰 이메일도 처리할 수 있지 않느냐고 주장할 수도 있겠으나, **비정형 BLOB 자료형 데이터에 대한 검색 질의 성능은 좋지 않다.**  
**BOLB 자료형이 고정된 크기 페이지를 연결하여 큰 데이터를 저장하도록 하고 있어서 해당 컬럼의 데이터를 접근할 때마다 많은 디스크 I/O가 발생한다는 것이 기본적 이유**다. 따라서 RDB는 바람직하지 않다.

- 분산 객체 저장소: 이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는것도 생각해볼 수 있다. 객체 저장소는 백업 데이터를 보관히기에는 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 스레드 등의 기능을 구현하기에는 그다지 좋지 않다.
- NoSQL 데이터베이스: 지메일은 구글 빅테이블을 저장소로 사용한다. 따라서 충분히 실현 가능한 방법이지만, 빅테이블은 오픈소스로 공개되어 있지 않다.


### 2.2 데이터 모델
데이터를 저장하는 한 가지 방법은 user_id를 파티션 키로 사용하여 특정한 사용자의 데이터는 항상 같은 샤드에 보관하는 것이다.  
- 파티션 키: 데이터를 여러 노드에 분산하는 구실을 한다. 일반적으로 통용되는 규칙은 데이터가 모든 노늗에 균등하게 분산되도록 하는 파티션 키를 골라야 하는 것이다. 
- 클러스터 키: 같은 파티션에 속한 데이터를 정렬하는 구실을 한다.

### 2.3 검색

데이터의 다양한 속성에 따라 필터링 기능이 포함되는 경우가 대다수다. 검색 기능을 제공하려면 데이터가 생성이나 삭제될 때마다 indexing 작업을 수행해야 한다.(색인 작업이 실시간으로 이루어져야 하는 경우)   
그에 반해 검색은 사용자가 '검색'버튼을 누를 때만 실행된다. 따라서 이러한 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.  

검색 기능을 지원하기 위해 ElasticSearch를 이용하는 방안과 데이터 저장소에 내장된 기본 검색 기능을 활용하는 방안의 두 가지 선택지를 비교해보자.  

**2.3.1 ElasticSearch**

<img width="576" alt="image" src="https://github.com/user-attachments/assets/f6a9d4dd-3bc3-4692-a8dd-1f41c63aab43">

- 질의가 대부분 사용자의 이메일 서버에서 실행되므로 user_id를 파티션 키로 사용하여 같은 사용자의 이메일은 같은 노드에 묶음
- 사용자는 검색 버튼을 누른 다음 결과가 수신될 때까지 기다린다. 따라서 검색 요청은 동기방식으로 처리
- 하지만, '이메일 전송', '이메일 수신', '이메일 삭제' 같은 이벤트는 처리 결과를 클라이언트로 전달할 필요는 없다. 필요한 것은 인덱싱 작업이고, 이 프로세스는 백그라운드 형태로 처리될 수 있다.
- 본 설계안에서는 카프카를 활용하여 인덱싱 작업을 시작하는 서비스와 실제로 인덱싱을 수행할 서비스 사이의 결합도를 낮춤

### 2.4 규모 확장성 및 가용성

<img width="585" alt="image" src="https://github.com/user-attachments/assets/82f7af77-be74-493e-89f6-3ab219591689">

- 사용자의 데이터 접근 패턴은 다른 사용자와 무관하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장이 가능할 것으로 기대
- 가용성 향상을 위해 데이터를 여러 데이터 센터에 다중화 하는 것이 필요
- 사용자는 네트워크 토폴로지 측면에서 보았을 때 자신과 물리적으로 가까운 메일 서버와 통신

