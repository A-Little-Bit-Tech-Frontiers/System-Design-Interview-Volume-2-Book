## 개략적 설계안

<img width="446" alt="image" src="https://github.com/user-attachments/assets/a475387c-2013-4f4d-9de4-82040a01a2ff">

최종적으로 위 설계안을 택하기 전에, 다른 대안은 어떤 것들이 있으며 다른 대안을 채택하지 않은 이유는 무엇인지 살펴보자.


## 데이터 모델


### 관계형 데이터베이스

SQL 데이터베이스는 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못한다. **수백만 개 레코드에 순위를 매기려면 대략 수십 초 정도가 걸리므로, 실시간성을 요구하는 애플리케이션에는 적합하지 않다.** 데이터가 지속적으로 변경되기 때문에 캐시 도입도 불가능하다.

즉, **관계형 데이터베이스는 본 시스템에 요구되는 다량의 읽기 부하를 처리하기 어렵다.** **일괄 작업으로 수행하면 RDB도 가능하겠지만, 일괄 처리 방식은 사용자에게 실시간 순위를 보여주어야 한다는 요구사항에 적합하지 않다.**

할 수 있는 최선은 index를 추가하고, LIMIT 절을 사용하여 스캔할 페이지 수를 제한하는 것이다.

```sql
SELECT (@rownum := @rownum + 1) AS rank, user_id, score
FROM leaderboard
ORDER BY score DESC
LIMIT 10
```

하지만 이 방식은 규모 확장성이 좋지 않다. **첫째, 특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 하므로 성능이 떨어진다.** **둘째, 이 접근 방식으로는 순위표 상단에 있지 않은 사용자의 순위를 간단히 찾을 수 없다.**

### Redis

레디스는 메모리 기반 키-값 저장소 시스템이다. 메모리에서 동작하므로 빠른 읽기 및 쓰기가 가능하다. 아울러 순위표 시스템 설계 문제를 해결하는 데 이상적인 **정렬 집합(sorted set)**이라는 자료형을 제공한다.

**Sorted Set(정렬 집합)이란?**

집합과 유사한 자료형이다. 정렬 집합에 저장된 각 원소는 점수에 연결되어 있다. 집합 내 원소는 고유해야 하지만 같은 점수는 있을 수도 있다. 점수는 정렬 집합 내 원소를 오름차순 정렬하는 데 이용된다.

순위표에는 정렬 집합이 정말 딱 어울린다. **Sorted Set은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료구조를 사용한다. 해시 테이블**은 사용자의 점수를 저장하기 위해서, **스킵 리스트**는 특정 점수를 딴 사용자들의 목록을 저장하기 위해 쓰인다. 사용자는 점수를 기준으로 정렬한다. 정렬 집합을 이해하는 좋은 방법은 아래 그림과 같이 점수 및 사용자 열이 있는 테이블로 생각하는 것이다. 이 테이블은 점수의 내림차순으로 정렬된다.

<img width="567" alt="image" src="https://github.com/user-attachments/assets/0fc2b6f0-9ea1-4779-97a0-29fb0453492d">


---


스킵 리스트는 **빠른 검색을 가능하게 하는 자료구조**다. **정렬된 연결 리스트에 다단계 index를 두는 구조**다. 사례를 들어보자. 아래 그림(스킵 리스트)에서 보듯이, 이 자료 구조의 근간은 정렬된 단방향 연결 리스트다. 이 연결 리스트에 삽입, 삭제, 검색 연산을 실행하는 시간 복잡도는 O(n)이다.

이들 연산이 더 빨리 실행되도록 하려면 어떻게 하면 될까? 한 가지 아이디어는 이진 탐색처럼 중간 지점에 더 빨리 도달할 수 있도록 하는 것이다. 이를 위해 중간 노드를 하나씩 건너뛰는 1차 색인(level-1 index)을 추가한 다음, 
1차 색인 노드를 하나씩 건너뛰는 2차 색인(level-2 index)을 추가한다. 즉, 새로운 index를 추가할 때마다 이전 차수의 노드를 하나씩 건너뛸 수 있도록 하는 것이다. 
노드 사이의 거리가 n-1이 되면 더 이상의 색인은 추가하지 않는다. 여기서 n은 노드의 총 개수이며, 아래 그림과 같이 다단계 색인을 사용하면 45가 있는지 훨씬 빠르게 검색할 수 있다.

<img width="599" alt="image" src="https://github.com/user-attachments/assets/4e3c579e-6ebe-4188-81d0-0ab27319cb82">


데이터의 양이 적을 때는 스킵 리스트의 속도 개선 효과가 분명하지 않다. 아래 그림은 5차 색인까지 사용하는 스킵 리스트의 사례다. 기본 리스트만 있는 경우에는 찾는 노드에 도달하기 위해 62개의 노드를 거쳐야 한다. 
스킵 리스트의 경우에는 11개의 노드만 통과하면 된다.  
Sorted Set은 삽입이나 갱신 연산을 할 때 모든 원소가 올바른 위치에 자동으로 배치되며 새 원소를 추가하거나 기존 원소를 검색하는 연산의 시간 복잡도가 O(log(n))이므로 RDB보다 성능이 좋다. 
반대로 RDB에서 특정 사용자의 순위를 계산하려면 서브쿼리문을 실행해야 한다.

```sql
SELECT *, (SELECT COUNT(*) FROM leaderboard lb2 WHERE lb2.score >= lb1.score) RANK
FROM leaderboard lb1
WHERE lb1.user_id = {:user_id};
```

**레디스 정렬 집합을 사용한 구현**

순위표 구현에 사용할 레디스 연산들은 무엇이 있을까?

- **ZADD**: **기존에 없던 사용자를 집합에 삽입**한다. 기존 사용자의 경우에는 점수를 업데이트한다. 실행 소요시간은 **O(log(n))**이다.
- **ZINCRBY**: **사용자 점수를 지정된 값만큼 증가**시킨다. 집합에 없는 사용자의 점수는 0에서 시작한다고 가정한다. 실행 소요시간은 **O(log(n))**이다.
- **ZRANGE/ZREVRANGE**: 점수에 따라 **정렬된 사용자 중에 특정 범위에 드는 사용자들을 가져온다.** 순서(오름차순 또는 내림차순), 항목 수, 시작 위치를 지정할 수 있다. 
실행 소요시간은 **O(log(m+n))이다. m: 가져올 항목 수, n: sorted set의 크기**
- **ZRANK/ZREVRANK**: **오름차순/내림차순 정렬하였을 때 특정 사용자의 위치**를 가져온다. 실행 시간은 **O(log(n))**이다.

### 저장소 요구사항

고려해야 할 또 다른 요소는 CPU 및 I/O 사용량  
개략적 추정치에 따르면 갱신 연산의 최대 QPS는 2500 정도였다. 이는 단일 레디스 서버로도 충분히 감당할 수 있는 부하

# 상세설계

### 클라우드 서비스를 이용하는 방안

두 번째 방안은 클라우드 인프라를 활용하는 것이다. **AWS API Gateway와 AWS Lambda**의 두 가지 기술을 사용할 것이다. API Gateway를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결할 수 있다. 이번 절에서는 람다 함수에 연결하는 사례를 살펴본다.

| API | 람다 함수 |
| --- | --- |
| GET /v1/scores | LeaderboardFetchTop10 |
| GET /v1/scores/{:user_id} | LeaderboardFetchPlayerBank |
| POST /v1/scores | LeaderboardUpdateScore |

AWS 람다는 가장 인기 있는 Serverless 중 하나다. 서버를 준비하거나 관리할 필요없이 코드를 실행할 수 있다. 람다는 필요할 때만 실행되며 트래픽에 따라 그 규모가 자동으로 확장된다. 

개략적으로 설명하자면 **API 게이트웨이를 호출하고, 이 게이트웨이는 적절한 람다 함수를 호출한다. 이 람다 함수는 스토리지 계층(MySQL 혹은 Redis)의 명령을 호출하여 얻은 결과를 API Gateway에 반환하며, API Gateway는 그 결과를 애플리케이션에 전달한다.**

**람다 함수를 사용하면 서버 인스턴스를 만들지 않아도 질의를 실행할 수 있다. AWS는 람다 함수에서 레디스를 호출할 수 있도록 클라이언트를 제공한다.**  

- 점수 획득
    
    <img width="669" alt="image" src="https://github.com/user-attachments/assets/5e4f830b-3bc7-4a68-923d-9047c5138f8d">

    
- 순위 검색
    
    <img width="667" alt="image" src="https://github.com/user-attachments/assets/5f37a7af-f80b-494b-bb5d-6721cc59f0a4">

  

## 레디스 규모 확장

5백만 DAU 정도라면 한 대의 레디스 캐시 서버로도 충분히 지원할 수 있다. 그러나 원래 규모의 100배인 5억 DAU를 처리해야 한다고 가정해보자. 최악의 경우 저장 용량은 65GB까지 필요하고, **250,000 QPS의 질의를 처리할 수 있어야 한다.** 이 정도의 규모를 감당하려면 **샤딩이 필요**하다.

### 데이터 샤딩 방안

고정 파티션과 해시 파티션의 두 가지 방식을 살펴보고, 그 가운데 하나를 택하도록 하겠다.

### 고정 파티션

<img width="693" alt="image" src="https://github.com/user-attachments/assets/371f6220-b0b7-4762-904b-46bbc67ea0c2">


이 기능이 제대로 작동하려면 **순위표 전반에 점수가 고르게 분포**되어야 함 
**그렇지 않다면 각 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야 함**   
그렇다면 **특정 사용자의 점수를 입력하거나 갱신할 때는 해당 사용자가 어느 샤드에 있는지 알아야 할 것이다.** MySQL 질의를 통해 사용자의 현재 점수를 계산하여 알아내는 것도 한 가지 방법이다.  
하지만 **사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 통해 알아내면 성능을 더 높일 수 있을 것이다.** 사용자의 점수가 높아져서 다른 샤드로 옮겨야 할 때는 기존 샤드에서 해당 사용자를 제거한 다음 새 샤드로 옮겨야 한다는 점에 유의해야 한다.

순위표에서 상위 10명의 플레이어를 가져오려면, 가장 높은 점수가 저장되는 샤드(즉, Sorted Set)에서 상위 10명을 가져오면 된다. 위 그림의 경우 점수 범위가 [901, 1000]인 마지막 샤드에 상위 10명의 사용자가 있다.  
특정 샤드에 속한 모든 사용자 수는 info keyspace 명령을 실행하면 O(1)시간에 알아낼 수 있다.

### 해시 파티션

두 번째 접근법은 **레디스 클러스터를 사용**하는 것으로, **사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우에 효과적**이다. 레디스 클러스터는 **여러 노드에 데이터를 자동으로 샤딩하는 방법**을 제공한다. 안정 해시는 사용하지 않지만, 각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다. 총 16384개 해시 슬롯이 있으며, CRC16(key) % 16384의 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다. 따라서 모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.

<img width="462" alt="image" src="https://github.com/user-attachments/assets/4b87a208-7ff1-4334-94f6-3776128ccb56">


점수를 갱신하려면 해당 사용자의 샤드를 찾아(CRC16(key) % 16384로 찾음) 거기서 해당 사용자 점수를 변경하기만 하면 된다. **상위 10명의 플레이어를 검색하는 것은 까다롭다.** 모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집(scatter-gather) 접근법을 사용해야 한다. 모든 샤드에 사용자를 질의하는 절차를 병렬화하면 지연 시간을 줄일 수는 있다.

이 방법에는 아래와 같은 문제가 있다.

- 상위 k개의 결과를 반환해야 하는 경우, 각 샤드에서 많은 데이터를 읽고 또 정렬해야 하므로 지연 시간이 늘어남
- 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어짐
- 특정 사용자의 순위를 결정할 간단한 방법이 없음

따라서 해당 설계안의 경우에는 **고정 파티션 방안**을 사용
