# 실시간 게임 순위표

## 개략적 설계안

<img width="387" alt="스크린샷 2024-08-01 오후 8 14 54" src="https://github.com/user-attachments/assets/08cc2422-35bf-4efd-ab1e-dce9bba0f630">

1. 사용자가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.
2. 게임 서비스는 해당 승리가 정당하고 유효한 것인지 확인한 다음 순위표 서비스에 점수 갱신 요청을 보낸다.
3. 순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.
4. 해당 사용자의 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
   5. 상위 10명 순위표
   6. 해당 사용자 순위

### 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가 ?

게임 점수가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면 카프카에 데이터를 넣는 것이 합리적이다. <br>
순위표 서비스, 분석 서비스, 푸시 알림 서비스 등 여러 소비자가 동일한 데이터를 사용할 수 있기 때문이다.

### 데이터 모델

#### 관계형 DB

<img width="225" alt="스크린샷 2024-08-01 오후 8 18 45" src="https://github.com/user-attachments/assets/fdb76188-5f83-4933-bf75-13de615cd297">

규모 확장성이 중요하지 않고 사용자 수가 많지 않다면 RDB를 이용할 가능성이 높다. <br>
사용자가 경연에서 승리하면 신규 사용자에게는 1점을 주고, 기존 사용자에게는 원래 점수에 1점을 더한다. <br>
사용자의 순위를 결정하려면 점수에 따라 테이블을 내림차순으로 정렬하면 된다.

이 방안은 레코드가 수백만 개 정도로 많아지면 성능이 너무 나빠지는 문제가 있다. <br>
수 백만 개의 레코드에 순위를 매기려면 대략 수십 초가 걸리므로, 실시간성을 요구하는 애플리케이션에는 적합하지 않다. <br>
데이터가 지속적으로 변경되기 때문에 캐시 도입도 불가능하다.

#### 레디스

순위표 시스템 설계에는 **sorted set**이 이상적이다. <br>
정렬 집합은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료구조를 사용한다. <br>
해시 테이블은 사용자의 점수를 저장하기 위해, 스킵 리스트는 특정 점수를 딴 사용자들의 목록을 저장하기 위해 쓰인다. 사용자는 점수를 기준으로 정렬한다.

<img width="542" alt="스크린샷 2024-08-01 오후 8 21 36" src="https://github.com/user-attachments/assets/3d393849-e20a-48e2-abf2-e9520e76da70">


1. 사용자가 점수를 획득한 경우

ZINCRBY를 호출하여 순위표상의 사용자 점수를 1만큼 증가시키거나, 아직 순위표 세트에 없는 경우에는 해당 사용자를 순위표 집합에 추가한다. <br>
ex) ZINCRBY leaderboard_feb_2021 1 'mary1934'

2. 사용자가 순위표 상위 10명을 조회하는 경우

가장 높은 점수를 받은 사용자부터 내림차순으로 정렬한 결과를 가져와야 하므로 ZREVERANGE를 호출한다. <br>
사용자 목록뿐 아니라 각 사용자의 현재 점수도 가져와야 하므로 WITHSCORES 속성도 함께 전달한다. <br>
ex) ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES

3. 사용자가 자기 순위를 조회하는 경우

ZREVRANK를 호출하여 특정 사용자의 순위를 가져올 수 있다. <br>
ex) ZREVRANK leaderboard_feb_2021 'mary1934'

4. 특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우

ZREVRANGE를 이용하여 특정한 사용자 전/후의 순위 사용자 목록을 얻을 수 있다. <br>
ex) ZREVRANGE leaderboard_feb_2021 357 365




