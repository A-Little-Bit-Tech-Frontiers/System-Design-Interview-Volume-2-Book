# 전자 지갑

## 개략적 설계안

### 인메모리 샤딩

<사용자, 잔액> 관계를 나타내기 좋은 자료구조는 해시 테이블이라고도 불리는 맵 또는 키-값 저장소이다. <br>
레디스 노드 한 대로는 100만 TPS는 벅차서, 클러스터를 구성하고 사용자 계정을 모든 노드에 분산시켜야 한다. (파티셔닝, 샤딩)

<img width="592" alt="스크린샷 2024-08-10 오후 8 48 37" src="https://github.com/user-attachments/assets/247360a5-79fa-4a92-90db-db73aebd2809">

> 이 설계는 작동은 하지만 정확성을 충족시키지 못한다. <br>
> 지갑 서비스는 이체할 때마다 두 개의 레디스 노드를 업데이트 하는데, 그 두 연산이 모두 성공하리라는 보장이 없다.

### 분산 트랜잭션

서로 다른 두 개 저장소 노드를 갱신하는 연산을 원자적으로 수행하려면 관계형 데이터베이스를 이용할 수 있다. <br>
클라이언트 A, B, C의 잔액 정보가 레디스 노드가 아닌 3개의 관계형 데이터베이스 노드로 분산된다.

<img width="619" alt="스크린샷 2024-08-10 오후 8 52 12" src="https://github.com/user-attachments/assets/9a54daaa-f7db-40ad-ba36-cc3bc53f5fe5">

> 트랜잭션 데이터베이스를 사용해도 이런 식이면 문제의 일부만 해결할 수 있다. <br>
> 한 이체 명령이 서로 다른 두 데이터베이스 서버에 있는 계정 두 개를 업데이트해야 할 가능성이 높은데, 이 두 작업이 정확히 동시에 처리된다는 보장이 없다. <br>
> 이를 해결하기 위해선 **2PC 커밋**이나 **보상 트랜잭션**을 사용해야 한다.

<img width="697" alt="스크린샷 2024-08-10 오후 8 54 42" src="https://github.com/user-attachments/assets/48dec16b-651a-4465-8c9d-9ccffcea7c3e">

### 이벤트 소싱

1. 명령
2. 이벤트
3. 상태
4. 상태 기계

#### 명령

명령은 외부에서 전달된, 의도가 명확한 요청이다. 예를 들어 고객 A에서 C로 $1를 이체하라는 요청은 명령이다. <br>
이벤트 소싱에서 순서는 아주 중요해서, 일반적으로 FIFO 큐에 저장된다.

#### 이벤트

명령은 의도가 명확하지만 사실이 아니기 떄문에 유효하지 않을 수도 있다. 가령 이체 후에 잔액이 음수가 된다면 이체는 실패한다. <br>
작업 이행 전에 반드시 명령의 유효성을 검사해야 한다. 그리고 검사를 통과한 명령은 반드시 이행되어야 한다. 명령 이행 결과를 이벤트라고 부른다.

1. 이벤트는 검증된 사실로, 실행이 끝난 상태다. 그래서 이벤트에 대해 이야기할 때는 과거 시제를 사용한다.
2. 명령에는 무작위성이나 I/O가 포함될 수 있지만, 이벤트는 결정론적이다. 이벤트는 과거에 실제로 있었던 일이다.

#### 상태

상태는 이벤트가 적용될 때 변경되는 내용이다. 지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액이다.

#### 상태 기계

상태 기계는 이벤트 소싱 프로세스를 구동한다.

1. 명령의 유효성을 검사하고 이벤트를 생성한다.
2. 이벤트를 적용하여 상태를 갱신한다.

<img width="435" alt="스크린샷 2024-08-10 오후 9 02 45" src="https://github.com/user-attachments/assets/b86e270a-7442-4db5-92cc-4c203345056d">


### 지갑 서비스 예시

지갑 서비스의 명령은 이체 요청이고, FIFO 큐에 기록된다. <br>
상태 기계는 명령을 큐에 들어간 순서대로 확인하고, 명령 하나를 읽을 때마다 계정에 충분한 잔액이 있는지 확인한다. <br>
충분하다면 상태 기계는 각 계정에 대한 이벤트를 만든다. 예를 들어 명령이 **A -> $1 -> C**라면 상태 기계는 **A: -$1**, **C: +$1**의 두 이벤트를 만든다. <br>

<img width="715" alt="스크린샷 2024-08-10 오후 9 05 51" src="https://github.com/user-attachments/assets/bccab8f7-a011-4a32-9c5c-9cec28ecd341">

### 재현성

이벤트 소싱이 갖는 장점은 **재현성**이다. <br>
분산 트랜잭션 방안의 경우 지갑 서비스는 갱신한 계정 잔액을 데이터베이스에 저장한다. 계정 잔액이 변경된 이유는 알기가 어렵다. <br>
또한 한 번 업데이트가 일어나고 나면 과거 잔액이 얼마였는지 알 수 없다.

하지만 이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성할 수 있다. <br>
이벤트 리스트는 불변이고 상태 기계 로직은 결정론적이므로 이벤트 이력을 재생하여 만들어낸 상태는 언제든 동일하다.

### CQRS

이벤트 소싱은 상태, 즉 계정 잔액을 공개하는 대신 모든 이벤트를 외부에 보낸다. <br>
따라서 이벤트를 수신하는 외부 주체가 직접 상태를 재구축할 수 있다.

<img width="742" alt="스크린샷 2024-08-10 오후 9 09 05" src="https://github.com/user-attachments/assets/7b499fb7-531b-4069-982f-351debff4175">





