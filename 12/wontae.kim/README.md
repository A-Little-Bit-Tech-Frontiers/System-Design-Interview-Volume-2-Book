# 12장 전자 지갑

간단한 메모리 기반 지갑 솔루션을 설계한다.

### 필요 지식

- **인메모리 샤딩**
    - 100만 TPS 처리를 위해서는 단일 Redis 노드로는 어렵기 때문에, 클러스터링을 통해 사용자 별로 여러 노드에 균등 분산시켜야 한다. 이를 **파티셔닝 or 샤딩** 이라고 한다.
    - 단, 이 방법은 이체 기능의 필수조건인 출금-잔액 업데이트, 즉 2개의 노드를 원자적 트랜잭션으로 온전히 업데이트 하지 못한다.
- **분산 트랜잭션 *****
    - 트랜잭션 기능을 제공하는 관계형 데이터베이스를 사용하면 원자적 트랜잭션의 일부 조건은 만족할 수 있다. 하지만 여전히 노드의 안정성에 대한 대비가 필요하다.
    - **2PC 알고리즘**
        - 저수준 방안 - 데이터베이스에 의존하기
            - 두 데이터베이스 노드간에 변경이 일어나는 레코드를 서로 응답을 받을때까지 모두 잠근다. 하나라도 실패하면 트랜잭션은 실패한다.
            - 이 방식은 SPOF (단일 장애 지점) 문제가 있다. 서로 응답을 하기까지 너무 오랜 시간을 잠그기 때문에 트랜잭션 비용이 비싸다.
        - 고수준 방안 - **Cordinator (조정자) 패턴 (TC/C)**
            - 조정자는 **모든 데이터베이스에 트랜잭션 명령**을 내리고, **모든 응답을 받은 후**에 시도-확정 절차로 처리한다. 하나라도 실패하면 시도-취소 절차로 처리한다.
            - 저수준 방안과 차이점은, **각 명령이 단일 트랜잭션으로, 성공 시 추가 트랜잭션을 발행할 수도 있고, 실패 시 상태를 되돌리는 보상 트랜잭션을 실행하는 방식이다.**
    - **Saga Pattern**
        - TC/C 패턴과 비슷한 보상 트랜잭션 기반 방식이다. 조정자가 필수가 아니며, 분산 조율 혹은 코디네이터를 둘 수도 있다.
        - 작업 실행이 선형적으로 순차적으로 실행된다. 보상 트랜잭션은 롤백 단계에서 역순차적으로 수행한다.
- **이벤트 소싱**
    - 지갑 서비스에 대해 감사를 받는 사례에서, DDD 설계 기반 기법인 이벤트 소싱을 적용할 수 있다.
    - 명령 / 이벤트 / 상태 / 상태 기계 라는 컴포넌트가 존재한다.
    - 명령은 FIFO Queue 를 통해 소싱되고, 이벤트는 단일 명령에 여러 이벤트가 생성될 수 있다. 상태는 사용자별 잔액을 표시하는 Hash Table 자료구조로 표현될 수 있다.
    - 상태 기계 (State Machine or FSM) 를 통해 모든 이벤트 소싱 프로세스가 작동한다.
    - 이벤트 소싱의 중요한 장점은 **재현성(repro-ducibility)** 이다. 이벤트 이력을 보관하고 있다면, **결정론적으로 작동하는 상태 기계 특성상 최종적인 상태는 반드시 동일하다.**
    - **CQRS Pattern (명령-질의 책임 분리) *****
        - 이벤트 소싱은 쓰기-읽기 책임을 효과적으로 분리하는데, 기록 상태 기계는 하나지만 읽기 상태 기계는 여러 개 존재할 수 있다. **기록 상태 기계가 이벤트를 발행하면, 읽기 상태 기계는 이 이벤트를 구독하여 자신의 상태를 따라서 업데이트 하는 방식**으로 클라이언트의 읽기 전용 상태를 만들 수 있다.
        - 이 방식을 통해 기록 상태 기계가 사용하는 원본 데이터를 대상으로 상태를 조작하거나, 특정 기간의 상태를 복원하는 등 여러 작업을 수행할 수 있다. 이렇게 하면 상태의 불일치가 일어날 수 있으나 **결과적 일관성** 모델을 따르기 때문에 결과적으로는 같아진다.

### 설계

- **고성능 이벤트 소싱**
    - 파일 기반 시스템 사용
        - Kafka 같은 원격 저장소가 아닌, 로컬 디스크에 저장하는 방안을 사용할 수 있다.
        - 데이터베이스 또한 SQLite, RockDB 등을 사용할 수 있다.
        - 스냅숏(Snapshot) 이라는 상태 파일을 두어 재현 시점의 상태로 사용하면 성능적으로도 좋다.
        - 파일 기반 시스템은 상태(Stateful) 서버이고 단일 장애 지점(SPOF) 문제를 가진다.
    - SPOF 문제를 위한 신뢰성 보장 알고리즘
        - **합의 기반 복제 (Raft 알고리즘)**
            - Raft 알고리즘을 사용하면, 모든 노드가 동일한 이벤트 목록에 합의하도록 보장한다. **노드의 절반 이상이 온라인 상태**면 모두에게 보관된 추가 전용 리스트는 같은 데이터를 가진다. 이는 즉,  **나머지 오프라인 노드의 장애는 견딜 수 있다는 의미이다.**
            - Raft 알고리즘에서 노드는 리더, 후보, 팔로어의 역할을 가질 수 있다. 리더는 하나만 존재하고, 외부 명령을 수신하며 클러스터의 노드 간 데이터를 안정적으로 복제하는 역할을 담당한다.
- **분산 이벤트 소싱**
    - 지갑 업데이트의 결과를 즉시 받으려면 CQRS 패턴을 도입해 볼 수 있다. 하지만 요청-응답 흐름이 느릴 수 있는데, 이는 주기적 Polling 에 의존해야 할 수 있기 때문이다. 또한, 일정 규모 이상이 되면 단일 래프트 그룹의 용량 문제를 해결하기 위해 데이터를 샤딩하고 분산 트랜잭션을 구현해야 한다.
- **TC/C 가 Raft 노드 그룹이 있는 파티션들을 조정하는 설계도**