# 증권 거래소

## 1. 개략적 설계안

<img width="616" alt="image" src="https://github.com/user-attachments/assets/15a05d3e-258c-4878-9081-6984b46f5b1e">  


**거래 흐름(trading flow)**  
지연 시간 요건이 엄격한, 중요 경로(critical path)다. 이 경로를 따라 흐르는 모든 정보는 신속하게 처리되어야 한다.  

1단계: 고객이 브로커의 웹 또는 모바일 앱을 통해 주문한다.  
2단계: 브로커가 주문을 거래소에 전송한다.  
3단계: 주문이 클라이언트 게이트웨이를 통해 거래소로 들어간다. 클라이언트 게이트웨이는 입력 유효성 검사, 속도 제한, 인증, 정규화 등과 같은 기본적인 게이트키핑(gatekeeping) 기능을 수행한다. 그런 다음 주문을 주문 관리자에게 전달한다.  
4-5단계: 주문 관리자가 위험 관리자가 설정한 규칙에 따라 위험성 점검을 수행한다.    
6단계: 위험성 점검 과정을 통과한 주문에 대해, 주문 관리자는 지갑에 주문 처리 자금이 충분한지 확인한다.   
7-9단계: 주문이 체결 엔진으로 전송된다. 체결 가능 주문이 발견되면 체결 엔진은 매수 측과 매도 측에 각각 하나씩 두 개의 집행(execution, Fill(충족)이라고도 부름) 기록을 생성한다. 
**나중에 그 과정을 재생할 때 항상 결정론적(deterministic)으로 동일한 결과가 나오도록 보장하기 위해 시퀀서(sequencer)는 주문 및 집행 기록을 일정 순서로 정렬**한다.  
10~14단계: 주문 집행 사실을 클라이언트에 전송한다.  
<br>

**시장 데이터 흐름(market data flow)**  
하나의 주문이 체결 엔진부터 데이터 서비스를 거쳐서 브로커로 전달되어 집행되기까지의 과정을 추적해보자.  


M1 단계: 체결 엔진은 주문이 체결되면 집행 기록 스트림을 만든다. 이 스트림은 시장 데이터 게시 서비스로 전송된다.  
M2 단계: 시장 데이터 게시 서비스는 집행 기록 및 주문 스트림에서 얻은 데이터를 시장 데이터로 사용하여 봉 차트와 호가 창을 구성한다. 그런 다음 시장 데이터를 데이터 서비스로 보낸다.  
M3 단계: 시장 데이터는 실시간 분석 전용 스토리지에 저장된다. 브로커는 데이터 서비스를 통해 실시간 시장 데이터를 읽는다. 브로커는 이 시장 데이터를 고객에게 전달한다.  
<br>

**보고 흐름(report flow)**  

R1 ~ R2 단계: 보고 서비스는 주문 및 실행 기록에서 보고에 필요한 모든 필드의 값을 모은 다음(예를 들어 client_id, price, quantity, order_type, filled_quantity, remaining_quantity 등) 그 값을 종합해 만든 레코드를 데이터베이스에 기록한다.

<br>

## 2. 거래흐름

### 2.1 체결엔진

체결 엔진(matching engine)은 교차 엔진(cross engine)이라고 한다. 체결 엔진의 주요 역할은 다음과 같다.

1. 각 주심 심벌에 대한 주문서 내지 호가 창을 유지 관리한다. 주문서 또는 호가 창은 특정 주식에 대한 매수 및 매도 주문 목록이다.  
2. 매수 주문과 매도 주문을 연결한다. 연결, 다시 말해 주문 체결 결과로 두 개의 집행 기록이 만들어진다. 체결은 빠르고 신속하게 처리되어야 한다.  
3. 집행 기록 스트림을 시장 데이터로 배포한다.  

가용성 높은 **체결 엔진 구현체가 만드는 체결 순서는 결정론적**이어야 한다. 즉, **입력으로 주어지는 주문 순서가 같으면 체결 엔진이 만드는 집행 기록 순서는 언제나 동일해야 한다.** 이러한 결정론적 특성이 고가용성의 토대가 된다.

### 2.2 시퀀서 

<img width="544" alt="image" src="https://github.com/user-attachments/assets/98c2f809-4a86-4847-9c54-a9b0c7a36014">

시퀀서에는 입력 시퀀서와 출력 시퀀서 두 가지가 있으며, 각각 고유한 ID를 두어 순서를 유지한다.  

시퀀서는 순서 ID만 생성하는 것이 아니며, 메시지 큐 역할도 한다. 

- 입력 시퀀서: 체결 엔진에 메시지(수신된 주문)를 보내는 큐 역할
- 출력 시퀀서: 주문 관리자에게 메시지(집행 기록)를 회신하는 큐 역할


### 2.3 주문 관리자 

주문 관리자는 한쪽에서는 주문을 받고 다른 쪽에서는 집행 기록을 받는다. 주문 상태를 관리하는 것이 주문 관리자의 역할이다. 

주문 관리자는 클라이언트 게이트웨이를 통해 주문을 수신하고 다음을 실행한다.

- 종합적 위험 점검 담당 컴포넌트에 주문을 보내어 위험성을 검토한다.  
- 사용자의 지갑에 거래를 처리하기에 충분한 자금이 있는지 확인한다.  
- 주문을 시퀀서에 전달한다. 시퀀서는 해당 주문에 순서 ID를 찍고 체결 엔진에 보내어 처리한다. 새 주문에는 많은 속성이 있지만 모든 속성을 체결 엔진에 보낼 필요는 없다. 메시지 크기를 줄이기 위해 주문 관리자는 필요한 속성만 전송한다.

또한 주문 관리자는 시퀀서를 통해 체결 엔진으로부터 집행 기록을 받는다. 주문 관리자는 체결된 주문에 대한 집행 기록을 클라이언트 게이트웨이를 통해 브로커에 반환한다.  
주문 관리자는 빠르고 효율적이며 정확해야 한다. 주문 관리자는 **주문의 현재 상태를 유지 관리**한다. 사실 **다양한 상태 변화(state transaction)를 관리**해야 하는 문제 때문에 주문 관리자의 구현은 아주 복잡하다. 


## 2.4 시장 데이터 흐름

<img width="561" alt="image" src="https://github.com/user-attachments/assets/c88870da-2aa5-4fb0-8366-90f822afc310">  

시장 데이터 게시 서비스(Market Data Publisher, MDP)는 체결 엔진에서 집행 기록을 수신하고 집행 기록 스트림에서 호가 창과 봉 차트를 만들어 낸다.


## 2.5 보고흐름

<img width="412" alt="image" src="https://github.com/user-attachments/assets/cd92186d-6700-484c-bbe8-8ca784c5a85e">  

보고 서비스는 정확성과 규정 준수가 핵심이다. 

입력으로 들어오는 주문과 그 결과로 나가는 집행 기록 모두에서 정보를 모아 속성들을 구성하는 것이 일반적 관행이다. 
들어오는 새 주문에는 주문 세부 정보만 있고, 나가는 집행 기록에는 보통 주문 ID, 가격, 수량 및 집행 상태 정보만 있기 때문이다. **보고 서비스는 그 두 가지 출처에서 오는 정보를 잘 병합**하여 보고서를 만든다.

<br>

## 3. 성능

지연 시간이 안정적인지 보는 좋은 척도는 p99 지연 시간  

**AS-IS**

핵심 경로에 네트워크를 통해 통신하는 컴포넌트가 많으면 총 네트워크 지연 시간은 한 자릿수 밀리초까지 늘어난다.
또한 시퀀서는 이벤트를 디스크에 저장하는 이벤트 저장소다. 순차적 쓰기의 성능 이점을 활용하여 효율적으로 설계한다 해도 디스크 엑세스 지연 시간은 여전히 수십 밀리초 단위다.

네트워크 및 디스크 엑세스 지연 시간을 모두 고려하면 총 end-to-end 지연 시간은 수십 밀리초에 달한다. 

<br>

**TO-BE**

모든 엑세스 지연 시간을 차단한다.

<img width="588" alt="image" src="https://github.com/user-attachments/assets/85f73e3d-0f91-4110-9eb2-1ac57d0eaf2a">

같은 서버 내 컴포넌트 간 통신은 이벤트 저장소인 **mmap을 사용**

**애플리케이션 루프의 주된 작업 실행 메커니즘은 while 순환문을 통해 실행할 작업을 계속 폴링(pollng)하는 것**이다. 엄격한 지연 시간 요건을 만족하려면 목적 달성에 가장 중요한 작업만 이 순환문 안에서 처리해야 한다.  
CPU 효율성을 극대화하기 위해 **애플리케이션 루프는 단일 스레드로 구현하며, 특정 CPU 코어에 고정**시킨다.  

- Context Switch 비용이 사라짐
- lock 경합이 없음
<br>

**mmap 컴포넌트**
- 파일을 프로세스의 메모리에 매핑하는 mmap(2)라는 이름의 POSIX 호환 UNIX 시스템 콜을 일컫는다.

mmap(2)은 프로세스 간 고성능 메모리 공유 메커니즘을 제공한다. 메모리에 매핑할 파일이 `/dev/shm`에 있을 때 성능 이점은 더욱 커진다. 
`/dev/shm` 에 위치한 파일에 mmap(2)을 수행하면 공유 메모리에 접근해도 디스크 I/O는 발생하지 않는다.

최신 거래소는 이를 활용하여 중요 경로에서 가능한 한 디스크 접근이 일어나지 않도록 한다.
**서버에서 mmap(2)를 사용하여 중요 경로에 놓인 구성 요소가 서로 통신할 때 이용할 메시지 버스를 구현하는 것이다.** 이 통신 경로를 사용하여 네트워크나 디스크에 접근하는 일은 없으며, 메시지 전송에 마이크로초 미만이다.  
이렇게 mmap(2)을 활용하여 만든 이벤트 저장소에 다음에 설명할 이벤트 소싱 설계 패러다임을 결합하면 거래소는 서버에 지연 시간이 낮은 마이크로서비스들을 구축할 수 있게된다.


> ”PIPE나 MQ처럼 통신을 통한 IPC를 구현하는 방법이 있는 반면에 데이터를 공유하는 공유 메모리 기법” 으로만 인지하던 공유 메모리 기법이,,,
단순히 “독립된 실행 주체들이 데이터를 공유하기 위해서 사용한다”가 아닌 성능 향상을 위해 한 서버에 모든 컴포넌트를 구성하고, 내부에서 공유 메모리를 통해 통신하는 것이 매우 인상 깊다..😭 👍👍


<br>

## 4. 이벤트 소싱

<img width="569" alt="image" src="https://github.com/user-attachments/assets/4c304e98-d00b-46c4-aa8d-e1a97a3a3a34">

왼쪽은 일반적인 데이터베이스 스키마다. 주문 상태를 추적하지만 현재 상태에 도달하는 방법에 대한 정보는 포함하지 않는다.  
오른쪽은 이벤트 소싱 아키텍처를 따르는 경우다. 주문 상태를 변경하는 모든 이벤트를 추적하므로, 모든 이벤트를 순서대로 재생하면 주문 상태를 복구할 수 있다.

> 책에서는 좀 극단적으로 표현했지만   사실, 이벤트 소싱이 아니더라도 append-only의 상태 변경 히스토리 테이블을 별도로 두면 된다고 생각한다.

<img width="430" alt="image" src="https://github.com/user-attachments/assets/de86e4ba-9eed-4ff9-95e8-6ea83787be73">

mmap 이벤트 저장소를 메시지 버스로 사용하는 이벤트 소싱 설계안

- 게이트웨이는 빠르고 간결한 인코딩을 위해 FIX를 SBE(FIX over Simple Binary Encoding)로 변환하고, 각 주문을 이벤트 저장소 클라이언트를 사용하여 미리 정의된 형식의 NewOrderEvent 형태로 전송한다(다이어그램에서는 ‘이벤트 저장소 항목’ 부분이다)
- 체결 엔진에 내장된 주문 관리자는 이벤트 저장소로부터 NewOrderEvent를 수신하면 유효성을 검사한 다음 내부 주문 상태에 추가한다. 그 후 해당 주문은 처리담당 CPU 코어로 전송된다.
- 주문이 체결되면 OrderFilledEvent가 생성되어 이벤트 저장소로 전송된다.
- 시장 데이터 프로세서 및 보고 서비스 같은 다른 구성요소는 이벤트 저장소를 구독하고, 이벤트를 받을 때마다 적절히 처리한다.


## 5. 고가용성

<img width="518" alt="image" src="https://github.com/user-attachments/assets/f505f005-ae8e-4cbe-9ed5-3b8d386d330b">

현재 설계안의 경우 무상태 서비스가 아니므로, 상태를 저장하는 컴포넌트는 사본 간에 데이터를 복사해야 한다.  
이 주/부 체결 엔진 설계안의 문제점은 단일 서버 안에서만 동작한다는 것이다. 고가용성을 달성하려면 이 개념을 여러 서버 또는 데이터 센터 전반으로 확장해야 한다. 
**주/부 체결 엔진이 아니라 주/부 서버의 클러스터를 구성해야 한다는 뜻**이다. 아울러 주 서버의 이벤트 저장소는 모든 부 서버로 복제해야 한다.

