# 13장 증권 거래소

### 요구사항

- 중소규모, 시간 내 거래를 지원하는 거래소 설계
- 초고가용성 필요 (무조건 99.99% 이상) 몇 초의 장애도 평판이 나빠진다.
- 결함 내성 (Fault Tolerance) 설계
- 왕복 지연 시간은 최대 밀리초 수준 (p99 지연시간이 낮아야 한다)
- 높은 보안성 (KYC 수행, 공개 자원에 대해 DDOS 공격 방지 필요)

### 개략적 설계

**데이터 모델**

- **호가 창  ****
    - 체결 엔진이 사용하는 핵심 자료구조로, 빠른 추가/취소/실행 속도 조건들을 위해 시간 복잡도를 **O(1)** 을 만족하도록 해야 한다.
    - 주문들을 가지고 있는 `orders` 라는 자료 구조는 효율적으로 만들려면 **이중 연결 리스트**로 변경하여 모든 삭제 연산이 O(1) 에 처리되도록 해야 한다.
    
    ```java
    /*
    PriceLevel - '가격'을 키로 가지는 '주문 목록(orders)'을 보유한 구조체.
    
    * 새 주문을 넣으면, orders 의 tail 에 하나가 추가되기 때문에 O(1)에 처리된다.
    * 주문 체결시, orders 의 head 를 삭제하기 때문에 O(1)에 처리된다.
    * 주문 취소시, orderMap 에서 order 를 삭제하는데, 이때 **order 의 이전 포인터**를 사용해
      이중 연결 리스트에서 해당 order 를 O(1)안에 삭제할 수 있다.
    */
    DoubleLinkedList<Order> orders; // 주문 처리 대기 목록
    LinkedHashMap<Price, PriceLevel> limitMap; // 매수 주문 처리
    HashMap<OrderId, Order> orderMap; // 주문 탐색용 딕셔너리, 이것으로 삭제할 주문을 찾는다.
    ```
    

- **봉 차트  ****
    - 데이터는 메모리 상주형 컬럼형 데이터베이스(KDB 등) 에 둔다. 장 마감 후에는 이력용 DB 로 옮긴다.
    - 초기 렌더링을 위한 봉 개수를 일정 수준으로 제한하고, 나머지는 디스크에 보관하고 필요 시 불러와서 추가적으로 렌더링 하도록 해서 최적화 할 수 있다.
    - 메모리 선 할당을 해둔 Ring Buffer 에 봉 데이터를 보관 시 (Object Polling) 새 객체 할당을 줄일 수 있다.

### 상세 설계

**성능**

매우 낮은 지연시간 요구조건을 만족하기 위해서는, 일반적인 MSA 구조가 아닌 최적화된 커스텀화가 필요하다. 거래소는 단일 서버로 네트워크 비용을 없애서 이 요구조건을 달성할 수 있지만, **mmap** 자료구조를 사용하는 이벤트 서비스를 사용한 이벤트 소싱을 적용해서 더 안정성 있는 아키텍처를 만들 수 있다.

- **mmap (memory-mapped file)**
    - 파일을 프로세스의 메모리에 매핑하는 UNIX System Call 이다.
    - 메모리에 파일의 내용을 직접 접근 하도록 하여 디스크 I/O 오버헤드를 없앨 수 있다.
    - 프로세스 간 메모리 공유가 가능해서 스레드 간 이벤트 저장소로 사용할 수 있게 된다.

**컴포넌트**

- 주문 관리자
    - 서비스는 Single Thread 및 단일 CPU 코어에 고정시킨다. 이를 통해 컨텍스트 스위칭, 잠금 경합 등의 동시성 문제를 제거할 수 있다.
- **이벤트 저장소**
    - 낮은 지연시간을 맞추기 위해, mmap 을 사용해서 디스크 I/O 비용을 제거한 빠른 메시지 버스로 구현한다.
    - 이벤트 저장소는 이벤트의 순서를 보장할 필요가 있는데, 순서를 쓰는 주체는 **시퀀서**이다. 여기서는 mmap 환경에 맞춘 시퀀서를 구현해야 하는데, 시퀀서는 이벤트 저장소에 순서에 맞춰 기록하는 역할만 수행해야 한다. 각 컴포넌트의 **Ring Buffer** 에서 이벤트를 가져와서 Sequence ID 를 부여해서 이벤트 저장소로 전송한다.
- 게이트웨이
    - 빠르고 간결한 인코딩을 위해 FIX(금융 정보 교환 프로토콜)을 SBE 로 변환하고, 각 주문을 이벤트 저장소 클라이언트를 통해 사전 정의된 **새 주문 이벤트**로 이벤트 저장소에 전송한다.

**이벤트 소싱 아키텍처**

- **mmap 이벤트 저장소 서비스**에 **이벤트 소싱** 아키텍처를 곁들이면 지연시간을 대폭 낮춘 MSA 를 구축할 수 있다.
- 고가용성을 보장하기 위해 데이터를 복제해 두어야 한다. 체결 엔진의 경우, 단일 서버에서 동작하는 방식을 클러스터로 확장해서 관리해야 한다. 그렇게 되면 주/부 클러스터를 구성해서 여러 서버 및 데이터 센터로 확장할 수 있다.
    - Raft 알고리즘을 적용한 Raft Cluster 에서 이벤트를 복제한 여러 mmap 이벤트 저장소 서비스를 둘 수 있다. 이 노드들을 운영하면 데이터 손실율이 0에 가깝다.
- **결정론**
    - **기능적 결정론 -** 시퀀서와 이벤트 소싱 아키텍처를 적용하면 순서가 보장되어 항상 같은 결과를 얻기에 기능적 결정론이라고 할 수 있다.
    - **지연 시간 결정론 -** 각 거래의 처리시간이 거의 같다는 의미
- **시장 데이터 게시 최적화**
    - 체결 엔진의 체결 결과를 받아 호가 창, 봉 차트를 재구축해서 구독자에게 Publish 한다. 고객 별로 데이터의 공개 수준을 제어할 수 있다. 생산자는 Ring Buffer 에 지속적으로 데이터를 넣고 소비자가 알아서 꺼내도록 한다. 별도의 객체 생성-삭제 및 잠금을 수행하지 않는다.
- **네트워킹 보안**
    - 공개된 데이터에 대해서는 무차별 요청 공격인 DDOS 에 노출되어 있어 동일한 데이터에 대해 읽기 전용 사본을 만드는 등으로 문제 범위를 최소화 한다.
    - 파라미터를 감춰서 URL 을 간소화 하거나, CDN 단에서 캐싱, Rate Limiting 기능을 사용해서 DDOS 공격을 어느정도 방지할 수 있다.